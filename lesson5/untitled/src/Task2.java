import java.util.HashMap;
import java.util.Map;

public class Task2 {
    public static void main(String[] args) {
        /*
        Даны 2 строки, написать код, который вернет true, если эти строки являются изоморфными и false, если нет.
        Строки изоморфные, если одну букву в первом слове можно заменить на некоторую букву во втором слове, при этом
        повторяющиеся буквы одного слова меняются на одну и ту же букву с сохранением порядка следования.
        (Например, add - egg изоморфны)
        буква может не меняться, а остаться такой же. (Например, note - code)
        Пример 1:
        Input: s = "foo", t = "bar"
        Output: false
        Пример 2:
        Input: s = "paper", t = "title"
        Output: true
         */
        System.out.println(ex_1("paper", "title"));  // Вызываем метод, передаем в нее параметры.
    }
    static  boolean ex_1(String s1, String s2){ //Создаём метод boolen, который будет возвращать значение
        // true или false. Метод будет принимать в себя параметры - строки

        //Сперва проверяем строки на длину.
        // Если длина строк не совпадает друг с другом, то возвращаем false, так как такие строки
        // не являются изоморфными.
        if (s1.length() != s2.length()){
            return false;
        }
        Map<Character, Character> map = new HashMap<>(); //Создаем экземпляр класса map, в который будут
        // добавляться пары ключ:значение.

        //Для того чтобы сравнить посимвольно строки друг с другом
        // создаем массив символов - под первую строку и под вторую.
        //Символы в первой строке будут являться ключами, во второй строке значениями.
        char[] c1 = s1.toCharArray(); //преобразуем первую строку в массив символов -> ключ
        char[] c2 = s2.toCharArray(); //преобразуем вторую строку в массив символов -> значение

        //Объявляем цикл for, в котором пройдемся по массиву с ключами с1
        //Необходимо проверить, есть ли ключ в map, если нет, то ключ добавляется в map и ему присваивается значение
        // (44 строка кода)
        //Если такой ключ уже есть в map, то необходимо убедиться совпадает ли значение текущего ключа на проверке со
        // значением уже внесенного ключа в map. Если значения не совпадают, то возвращаем false (45 строка)
        // Повторяющийся кюч должен иметь значение, которое должно совпадать со значением уже записанного повторяющегося ключа.
        for (int i = 0; i < c1.length; i++) {  //Input: s = "paper", t = "title" p=t, a=i, e=l, r=e.
            if (map.containsKey(c1[i])){ //проверяем, есть ли ключ в нашем map
                if (c2[i] !=map.get(c1[i])){
                    return false;
                }
            }else { //иначе, если ключа нет, то вносим ключ в map и присваиваем ему значение
                map.put(c1[i], c2[i]);
            }
        }
        return true; //возвращаем true

    }
}
